{"version":3,"sources":["webpack:///./node_modules/mitt/dist/mitt.es.js","webpack:///./node_modules/node-libs-browser/mock/process.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/vue-router/dist/vue-router.esm-bundler.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack:///./node_modules/vue/dist/vue.runtime.esm-bundler.js","webpack:///./node_modules/normalize-wheel/src/isEventSupported.js","webpack:///./node_modules/normalize-wheel/src/UserAgent_DEPRECATED.js","webpack:///./node_modules/normalize-wheel/src/ExecutionEnvironment.js","webpack:///./node_modules/normalize-wheel/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/normalize-wheel/src/normalizeWheel.js","webpack:///./node_modules/path-browserify/index.js"],"names":["all","n","Map","on","t","e","i","get","push","set","off","splice","indexOf","emit","slice","map","exports","nextTick","fn","args","Array","prototype","call","arguments","shift","setTimeout","apply","platform","arch","execPath","title","pid","browser","env","argv","binding","name","Error","path","cwd","chdir","dir","resolve","exit","kill","umask","dlopen","uptime","memoryUsage","uvCounters","features","module","webpackPolyfill","deprecate","paths","children","Object","defineProperty","enumerable","l","hasSymbol","Symbol","toStringTag","PolySymbol","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","window","isESModule","obj","__esModule","assign","applyToParams","params","newParams","key","value","isArray","noop","TRAILING_SLASH_RE","removeTrailingSlash","replace","parseURL","parseQuery","location","currentLocation","query","searchString","hash","searchPos","hashPos","length","resolveRelativePath","fullPath","stringifyURL","stringifyQuery","stripBase","pathname","base","toLowerCase","isSameRouteLocation","a","b","aLastIndex","matched","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","aliasOf","keys","isSameRouteLocationParamsValue","isEquivalentArray","every","to","from","startsWith","fromSegments","split","toSegments","toPosition","segment","position","join","NavigationType","NavigationDirection","normalizeBase","baseEl","document","querySelector","getAttribute","BEFORE_HASH_RE","createHref","getElementPosition","el","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","left","top","computeScrollPosition","pageXOffset","pageYOffset","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getElementById","style","scrollTo","getScrollKey","delta","history","state","scrollPositions","saveScrollPosition","scrollPosition","getSavedScrollPosition","scroll","delete","createBaseLocation","protocol","host","createCurrentLocation","search","pathFromHash","useHistoryListeners","historyState","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","listener","type","pop","direction","forward","back","unknown","pauseListeners","listen","callback","teardown","index","beforeUnloadListener","replaceState","destroy","removeEventListener","addEventListener","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","err","console","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","createWebHashHistory","isRouteLocation","route","isRouteName","START_LOCATION_NORMALIZED","undefined","meta","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","createRouterError","isNavigationFailure","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","parse","match","stringify","avoidDuplicatedSlash","endsWith","param","text","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","test","createRouteRecordMatcher","record","parent","parser","matcher","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","mergeOptions","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","isAliasRecord","removeRoute","insertMatcher","matcherRef","getRoutes","paramsFromLocation","filter","k","find","m","parentMatcher","unshift","mergeMetaFields","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","Set","updateGuards","enterCallbacks","default","component","propsObject","reduce","defaults","partialOptions","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","decodeURIComponent","hasLeadingIM","searchParams","searchParam","eqPos","currentValue","values","v","normalizeQuery","normalizedQuery","useCallbacks","handlers","add","handler","reset","list","guardToPromiseFn","guard","enterCallbackArray","Promise","reject","next","valid","guardReturn","guardCall","then","catch","extractComponentsGuards","guardType","guards","rawComponent","isRouteComponent","__vccOpts","componentPromise","resolved","resolvedComponent","useLink","router","currentRoute","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","guardEvent","href","RouterLinkImpl","String","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","slots","link","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","class","RouterLink","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","target","preventDefault","outer","inner","innerValue","outerValue","some","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","attrs","injectedRoute","routeToDisplay","depth","matchedRouteRef","viewRef","instance","oldInstance","oldName","size","flush","matchedRoute","ViewComponent","currentName","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","ref","slot","slotContent","RouterView","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","matcherLocation","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","failure","handleScroll","triggerError","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","markAsReady","removeHistoryListener","setupListeners","_from","info","ready","readyHandlers","errorHandlers","isReady","started","installedApps","beforeEach","beforeResolve","afterEach","onError","app","this","config","globalProperties","$router","reactiveRoute","provide","unmountApp","unmount","promise","len","Math","max","recordFrom","recordTo","MapShim","getIndex","arr","result","entry","class_1","__entries__","configurable","entries","has","clear","ctx","_i","_a","global$1","global","self","Function","requestAnimationFrame$1","requestAnimationFrame","Date","now","trailingTimeout","throttle","delay","leadingCall","trailingCall","lastCallTime","resolvePending","proxy","timeoutCallback","timeStamp","REFRESH_DELAY","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","addObserver","observer","connect_","removeObserver","observers","disconnect_","changesDetected","updateObservers_","activeObservers","gatherActive","hasActive","broadcastActive","observe","attributes","childList","characterData","subtree","disconnect","_b","propertyName","isReflowProperty","getInstance","instance_","defineConfigurable","writable","getWindowOf","ownerGlobal","ownerDocument","defaultView","emptyRect","createRectInit","toFloat","parseFloat","getBordersSize","styles","positions","getPaddings","paddings","positions_1","getSVGContentRect","bbox","getBBox","width","height","getHTMLElementContentRect","clientWidth","clientHeight","getComputedStyle","horizPad","right","vertPad","bottom","boxSizing","round","isDocumentElement","vertScrollbar","horizScrollbar","abs","isSVGGraphicsElement","SVGGraphicsElement","SVGElement","getContentRect","createReadOnlyRect","x","y","Constr","DOMRectReadOnly","rect","create","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","broadcastRect","ResizeObserverEntry","rectInit","contentRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","TypeError","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","_this","observation","WeakMap","ResizeObserver","method","useHasFeature","ExecutionEnvironment","isEventSupported","eventNameSuffix","capture","canUseDOM","eventName","isSupported","element","createElement","setAttribute","implementation","hasFeature","_ie","_firefox","_opera","_webkit","_chrome","_ie_real_version","_osx","_windows","_linux","_android","_win64","_iphone","_ipad","_native","_mobile","_populated","_populate","uas","navigator","userAgent","agent","exec","os","NaN","documentMode","trident","ver","UserAgent_DEPRECATED","ie","ieCompatibilityMode","ie64","firefox","opera","webkit","safari","chrome","windows","osx","linux","iphone","mobile","nativeApp","android","ipad","canUseWorkers","Worker","canUseEventListeners","attachEvent","canUseViewport","screen","isInWorker","g","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","normalizeWheel","event","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","getEventType","normalizeArray","parts","allowAboveRoot","up","last","basename","matchedSlash","charCodeAt","xs","f","res","resolvedPath","resolvedAbsolute","process","charAt","p","normalize","isAbsolute","trailingSlash","substr","relative","trim","fromParts","toParts","min","samePartsLength","outputParts","concat","sep","delimiter","dirname","code","hasRoot","ext","extname","startDot","startPart","preDotState","str"],"mappings":"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","file":"js/chunk-vendors~9c5b28f6.8b7271b8.js","sourcesContent":["export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n","exports.nextTick = function nextTick(fn) {\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    setTimeout(function () {\n        fn.apply(null, args);\n    }, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*!\n  * vue-router v4.0.6\n  * (c) 2021 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, defineComponent, reactive, watchEffect, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\r\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\r\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\r\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\r\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\r\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\r\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nlet noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    let query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || pathname.toLowerCase().indexOf(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    let aLastIndex = a.matched.length - 1;\r\n    let bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (let key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        let positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    let foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash based url\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        let pathFromHash = hash.slice(1);\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    let currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    let historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        /**\r\n         * if a base tag is provided and we are on a normal domain, we have to\r\n         * respect the provided `base` attribute because pushState() will use it and\r\n         * potentially erase anything before the `#` like at\r\n         * https://github.com/vuejs/vue-router-next/issues/685 where a base of\r\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n         * base tag we can just use everything after the `#`.\r\n         */\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? (location.host && document.querySelector('base')\r\n                ? base\r\n                : base.slice(hashIndex)) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/vue-router-next/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (let callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname + location.search : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (base.indexOf('#') < 0)\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    let score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern =\r\n                        // avoid an optional / if there are more segments e.g. /:p?-static\r\n                        // or /:p?-:p2\r\n                        optional && segment.length < 2\r\n                            ? `(?:/${subPattern})`\r\n                            : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // if we have more than one optional param like /:a?-static we\r\n                            // don't need to care about the optional param\r\n                            if (segment.length < 2) {\r\n                                // remove the last slash as we could be at the end\r\n                                if (path.endsWith('/'))\r\n                                    path = path.slice(0, -1);\r\n                                // do not append a slash on the next iteration\r\n                                else\r\n                                    avoidDuplicatedSlash = true;\r\n                            }\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                customRe = '';\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        let isRootAdd = !originalRecord;\r\n        let mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                    // the aliases are always of the same kind as the original since they\r\n                    // are defined on the same record\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            let { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                let parentPath = parent.record.path;\r\n                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                let children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            // TODO: add normalized records for more flexibility\r\n            // if (parent && isAliasRecord(originalRecord)) {\r\n            //   parent.children.push(originalRecord)\r\n            // }\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            let index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        // console.log('i is', { i })\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0)\r\n            i++;\r\n        // console.log('END i is', { i })\r\n        // while (i < matchers.length && matcher.score <= matchers[i].score) i++\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    let newParams = {};\r\n    for (let key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: new Set(),\r\n        updateGuards: new Set(),\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (let name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    let options = {};\r\n    for (let key in defaults) {\r\n        options[key] =\r\n            key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\r\nfunction checkSameParams(a, b) {\r\n    for (let key of a.keys) {\r\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (let key of b.keys) {\r\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (let key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\n\n/**\r\n * Encoding Rules  = Space Path:  \" < > # ? { } Query:  \" < > # & = Hash:  \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst PLUS_RE = /\\+/g; // %2B\r\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\nconst ENC_SPACE_RE = /%20/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return (commonEncode(text)\r\n        // Encode the space as +, encode the + to differentiate it from the space\r\n        .replace(PLUS_RE, '%2B')\r\n        .replace(ENC_SPACE_RE, '+')\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^'));\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        // pre decode the + into space\r\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\r\n        // allow the = character\r\n        let eqPos = searchParam.indexOf('=');\r\n        let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        if (search.length)\r\n            search += '&';\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined)\r\n                search += key;\r\n            continue;\r\n        }\r\n        // keep null values\r\n        let values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        for (let i = 0; i < values.length; i++) {\r\n            // only append & with i > 0\r\n            search += (i ? '&' : '') + key;\r\n            if (values[i] != null)\r\n                search += ('=' + values[i]);\r\n        }\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (let key in query) {\r\n        let value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(record, name, guard) {\r\n    const removeFromList = () => {\r\n        record[name].delete(guard);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        record[name].add(guard);\r\n    });\r\n    record[name].add(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-ignore: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!rawComponent ||\r\n                    (typeof rawComponent !== 'object' &&\r\n                        typeof rawComponent !== 'function')) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\r\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\r\n                    // throw to ensure we stop here but warn to ensure the message isn't\r\n                    // missed by the user\r\n                    throw new Error('Invalid route component');\r\n                }\r\n                else if ('then' in rawComponent) {\r\n                    // warn if user wrote import('/component.vue') instead of () =>\r\n                    // import('./component.vue')\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\r\n                        `Promise instead of a function that returns a Promise. Did you ` +\r\n                        `write \"import('./MyPage.vue')\" instead of ` +\r\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\r\n                        `production if not fixed.`);\r\n                    let promise = rawComponent;\r\n                    rawComponent = () => promise;\r\n                }\r\n                else if (rawComponent.__asyncLoader &&\r\n                    // warn only once per component\r\n                    !rawComponent.__warnedDefineAsync) {\r\n                    rawComponent.__warnedDefineAsync = true;\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\r\n                        `using \"defineAsyncComponent()\". ` +\r\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\r\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\r\n                }\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                let options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                else {\r\n                    // display the error if any\r\n                    componentPromise = componentPromise.catch(console.error);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // __vccOpts is added by vue-class-component and contain the regular options\r\n                    let options = resolvedComponent.__vccOpts || resolvedComponent;\r\n                    const guard = options[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        let { matched } = route.value;\r\n        let { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        let currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        let parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e))\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\r\n        return Promise.resolve();\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        replace: Boolean,\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    setup(props, { slots }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && true) {\r\n            const instance = getCurrentInstance();\r\n            watchEffect(() => {\r\n                if (!instance)\r\n                    return;\r\n                instance.__vrl_route = link.route;\r\n            }, { flush: 'post' });\r\n            watchEffect(() => {\r\n                if (!instance)\r\n                    return;\r\n                instance.__vrl_active = link.isActive;\r\n                instance.__vrl_exactActive = link.isExactActive;\r\n            }, { flush: 'post' });\r\n        }\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', {\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    href: link.href,\r\n                    // this would override user added attrs but Vue will still add\r\n                    // the listener so we end up triggering both\r\n                    onClick: link.navigate,\r\n                    class: elClass.value,\r\n                }, children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-ignore getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-ignore getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (let key in inner) {\r\n        let innerValue = inner[key];\r\n        let outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterView',\r\n    // #674 we manually inherit them\r\n    inheritAttrs: false,\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routerViewLocationKey);\r\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        provide(routerViewLocationKey, routeToDisplay);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards. With async setup, the\r\n                // mounting component will mount before the matchedRoute changes,\r\n                // making instance === oldInstance, so we check if guards have been\r\n                // added before. This works because we remove guards when\r\n                // unmounting/deactivating components\r\n                if (from && from !== to && instance && instance === oldInstance) {\r\n                    if (!to.leaveGuards.size) {\r\n                        to.leaveGuards = from.leaveGuards;\r\n                    }\r\n                    if (!to.updateGuards.size) {\r\n                        to.updateGuards = from.updateGuards;\r\n                    }\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = routeToDisplay.value;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            normalizeSlot(slots.default, { Component: component, route }) ||\r\n                component);\r\n        };\r\n    },\r\n});\r\nfunction normalizeSlot(slot, data) {\r\n    if (!slot)\r\n        return null;\r\n    const slotContent = slot(data);\r\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\r\n}\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\nfunction getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n    // @ts-ignore\n    return typeof navigator !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n            ? global\n            : {};\n}\n\nconst HOOK_SETUP = 'devtools-plugin:setup';\n\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const hook = getDevtoolsGlobalHook();\n    if (hook) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const target = getTarget();\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor,\n            setupFn\n        });\n    }\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\r\n    const copy = assign({}, routeLocation, {\r\n        // remove variables that can contain vue instances\r\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\r\n    });\r\n    return {\r\n        _custom: {\r\n            type: null,\r\n            readOnly: true,\r\n            display: routeLocation.fullPath,\r\n            tooltip,\r\n            value: copy,\r\n        },\r\n    };\r\n}\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\n// to support multiple router instances\r\nlet routerId = 0;\r\nfunction addDevtools(app, router, matcher) {\r\n    // Take over router.beforeEach and afterEach\r\n    // make sure we are not registering the devtool twice\r\n    if (router.__hasDevtools)\r\n        return;\r\n    router.__hasDevtools = true;\r\n    // increment to support multiple router instances\r\n    const id = routerId++;\r\n    setupDevtoolsPlugin({\r\n        id: 'org.vuejs.router' + (id ? '.' + id : ''),\r\n        label: 'Vue Router',\r\n        packageName: 'vue-router',\r\n        homepage: 'https://next.router.vuejs.org/',\r\n        logo: 'https://vuejs.org/images/icons/favicon-96x96.png',\r\n        componentStateTypes: ['Routing'],\r\n        app,\r\n    }, api => {\r\n        // display state added by the router\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.instanceData) {\r\n                payload.instanceData.state.push({\r\n                    type: 'Routing',\r\n                    key: '$route',\r\n                    editable: false,\r\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\r\n                });\r\n            }\r\n        });\r\n        // mark router-link as active\r\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\r\n            if (node.name === 'RouterLink') {\r\n                if (componentInstance.__vrl_route) {\r\n                    node.tags.push({\r\n                        label: componentInstance.__vrl_route.path,\r\n                        textColor: 0,\r\n                        backgroundColor: ORANGE_400,\r\n                    });\r\n                }\r\n                if (componentInstance.__vrl_exactActive) {\r\n                    node.tags.push({\r\n                        label: 'exact',\r\n                        textColor: 0,\r\n                        backgroundColor: LIME_500,\r\n                    });\r\n                }\r\n                if (componentInstance.__vrl_active) {\r\n                    node.tags.push({\r\n                        label: 'active',\r\n                        textColor: 0,\r\n                        backgroundColor: BLUE_600,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        watch(router.currentRoute, () => {\r\n            // refresh active state\r\n            refreshRoutesView();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(routerInspectorId);\r\n        });\r\n        const navigationsLayerId = 'router:navigations:' + id;\r\n        api.addTimelineLayer({\r\n            id: navigationsLayerId,\r\n            label: `Router${id ? ' ' + id : ''} Navigations`,\r\n            color: 0x40a8c4,\r\n        });\r\n        // const errorsLayerId = 'router:errors'\r\n        // api.addTimelineLayer({\r\n        //   id: errorsLayerId,\r\n        //   label: 'Router Errors',\r\n        //   color: 0xea5455,\r\n        // })\r\n        router.onError(error => {\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'Error',\r\n                    subtitle: 'An uncaught error happened during navigation',\r\n                    logType: 'error',\r\n                    time: Date.now(),\r\n                    data: { error },\r\n                },\r\n            });\r\n        });\r\n        // attached to `meta` and used to group events\r\n        let navigationId = 0;\r\n        router.beforeEach((to, from) => {\r\n            const data = {\r\n                guard: formatDisplay('beforeEach'),\r\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\r\n                to: formatRouteLocation(to, 'Target location'),\r\n            };\r\n            // Used to group navigations together, hide from devtools\r\n            Object.defineProperty(to.meta, '__navigationId', {\r\n                value: navigationId++,\r\n            });\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: Date.now(),\r\n                    title: 'Start of navigation',\r\n                    data,\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        router.afterEach((to, from, failure) => {\r\n            const data = {\r\n                guard: formatDisplay('afterEach'),\r\n            };\r\n            if (failure) {\r\n                data.failure = {\r\n                    _custom: {\r\n                        type: Error,\r\n                        readOnly: true,\r\n                        display: failure ? failure.message : '',\r\n                        tooltip: 'Navigation Failure',\r\n                        value: failure,\r\n                    },\r\n                };\r\n                data.status = formatDisplay('');\r\n            }\r\n            else {\r\n                data.status = formatDisplay('');\r\n            }\r\n            // we set here to have the right order\r\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\r\n            data.to = formatRouteLocation(to, 'Target location');\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'End of navigation',\r\n                    time: Date.now(),\r\n                    data,\r\n                    logType: failure ? 'warning' : 'default',\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        /**\r\n         * Inspector of Existing routes\r\n         */\r\n        const routerInspectorId = 'router-inspector:' + id;\r\n        api.addInspector({\r\n            id: routerInspectorId,\r\n            label: 'Routes' + (id ? ' ' + id : ''),\r\n            icon: 'book',\r\n            treeFilterPlaceholder: 'Search routes',\r\n        });\r\n        function refreshRoutesView() {\r\n            // the routes view isn't active\r\n            if (!activeRoutesPayload)\r\n                return;\r\n            const payload = activeRoutesPayload;\r\n            // children routes will appear as nested\r\n            let routes = matcher.getRoutes().filter(route => !route.parent);\r\n            // reset match state to false\r\n            routes.forEach(resetMatchStateOnRouteRecord);\r\n            // apply a match state if there is a payload\r\n            if (payload.filter) {\r\n                routes = routes.filter(route => \r\n                // save matches state based on the payload\r\n                isRouteMatching(route, payload.filter.toLowerCase()));\r\n            }\r\n            // mark active routes\r\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\r\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\r\n        }\r\n        let activeRoutesPayload;\r\n        api.on.getInspectorTree(payload => {\r\n            activeRoutesPayload = payload;\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                refreshRoutesView();\r\n            }\r\n        });\r\n        /**\r\n         * Display information about the currently selected route record\r\n         */\r\n        api.on.getInspectorState(payload => {\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                const routes = matcher.getRoutes();\r\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\r\n                if (route) {\r\n                    payload.state = {\r\n                        options: formatRouteRecordMatcherForStateInspector(route),\r\n                    };\r\n                }\r\n            }\r\n        });\r\n        api.sendInspectorTree(routerInspectorId);\r\n        api.sendInspectorState(routerInspectorId);\r\n    });\r\n}\r\nfunction modifierForKey(key) {\r\n    if (key.optional) {\r\n        return key.repeatable ? '*' : '?';\r\n    }\r\n    else {\r\n        return key.repeatable ? '+' : '';\r\n    }\r\n}\r\nfunction formatRouteRecordMatcherForStateInspector(route) {\r\n    const { record } = route;\r\n    const fields = [\r\n        { editable: false, key: 'path', value: record.path },\r\n    ];\r\n    if (record.name != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'name',\r\n            value: record.name,\r\n        });\r\n    }\r\n    fields.push({ editable: false, key: 'regexp', value: route.re });\r\n    if (route.keys.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'keys',\r\n            value: {\r\n                _custom: {\r\n                    type: null,\r\n                    readOnly: true,\r\n                    display: route.keys\r\n                        .map(key => `${key.name}${modifierForKey(key)}`)\r\n                        .join(' '),\r\n                    tooltip: 'Param keys',\r\n                    value: route.keys,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    if (record.redirect != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'redirect',\r\n            value: record.redirect,\r\n        });\r\n    }\r\n    if (route.alias.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'aliases',\r\n            value: route.alias.map(alias => alias.record.path),\r\n        });\r\n    }\r\n    fields.push({\r\n        key: 'score',\r\n        editable: false,\r\n        value: {\r\n            _custom: {\r\n                type: null,\r\n                readOnly: true,\r\n                display: route.score.map(score => score.join(', ')).join(' | '),\r\n                tooltip: 'Score used to sort routes',\r\n                value: route.score,\r\n            },\r\n        },\r\n    });\r\n    return fields;\r\n}\r\n/**\r\n * Extracted from tailwind palette\r\n */\r\nconst PINK_500 = 0xec4899;\r\nconst BLUE_600 = 0x2563eb;\r\nconst LIME_500 = 0x84cc16;\r\nconst CYAN_400 = 0x22d3ee;\r\nconst ORANGE_400 = 0xfb923c;\r\n// const GRAY_100 = 0xf4f4f5\r\nconst DARK = 0x666666;\r\nfunction formatRouteRecordForInspector(route) {\r\n    const tags = [];\r\n    const { record } = route;\r\n    if (record.name != null) {\r\n        tags.push({\r\n            label: String(record.name),\r\n            textColor: 0,\r\n            backgroundColor: CYAN_400,\r\n        });\r\n    }\r\n    if (record.aliasOf) {\r\n        tags.push({\r\n            label: 'alias',\r\n            textColor: 0,\r\n            backgroundColor: ORANGE_400,\r\n        });\r\n    }\r\n    if (route.__vd_match) {\r\n        tags.push({\r\n            label: 'matches',\r\n            textColor: 0,\r\n            backgroundColor: PINK_500,\r\n        });\r\n    }\r\n    if (route.__vd_exactActive) {\r\n        tags.push({\r\n            label: 'exact',\r\n            textColor: 0,\r\n            backgroundColor: LIME_500,\r\n        });\r\n    }\r\n    if (route.__vd_active) {\r\n        tags.push({\r\n            label: 'active',\r\n            textColor: 0,\r\n            backgroundColor: BLUE_600,\r\n        });\r\n    }\r\n    if (record.redirect) {\r\n        tags.push({\r\n            label: 'redirect: ' +\r\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\r\n            textColor: 0xffffff,\r\n            backgroundColor: DARK,\r\n        });\r\n    }\r\n    // add an id to be able to select it. Using the `path` is not possible because\r\n    // empty path children would collide with their parents\r\n    let id = String(routeRecordId++);\r\n    record.__vd_id = id;\r\n    return {\r\n        id,\r\n        label: record.path,\r\n        tags,\r\n        children: route.children.map(formatRouteRecordForInspector),\r\n    };\r\n}\r\n//  incremental id for route records and inspector state\r\nlet routeRecordId = 0;\r\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\r\nfunction markRouteRecordActive(route, currentRoute) {\r\n    // no route will be active if matched is empty\r\n    // reset the matching state\r\n    const isExactActive = currentRoute.matched.length &&\r\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\r\n    route.__vd_exactActive = route.__vd_active = isExactActive;\r\n    if (!isExactActive) {\r\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\r\n    }\r\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\r\n}\r\nfunction resetMatchStateOnRouteRecord(route) {\r\n    route.__vd_match = false;\r\n    route.children.forEach(resetMatchStateOnRouteRecord);\r\n}\r\nfunction isRouteMatching(route, filter) {\r\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\r\n    route.__vd_match = false;\r\n    if (!found || found.length < 3) {\r\n        return false;\r\n    }\r\n    // use a regexp without $ at the end to match nested routes better\r\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\r\n    if (nonEndingRE.test(filter)) {\r\n        // mark children as matches\r\n        route.children.forEach(child => isRouteMatching(child, filter));\r\n        // exception case: `/`\r\n        if (route.record.path !== '/' || filter === '/') {\r\n            route.__vd_match = route.re.test(filter);\r\n            return true;\r\n        }\r\n        // hide the / route\r\n        return false;\r\n    }\r\n    const path = route.record.path.toLowerCase();\r\n    const decodedPath = decode(path);\r\n    // also allow partial matching on the path\r\n    if (!filter.startsWith('/') &&\r\n        (decodedPath.includes(filter) || path.includes(filter)))\r\n        return true;\r\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\r\n        return true;\r\n    if (route.record.name && String(route.record.name).includes(filter))\r\n        return true;\r\n    return route.children.some(child => isRouteMatching(child, filter));\r\n}\r\nfunction omit(obj, keys) {\r\n    const ret = {};\r\n    for (let key in obj) {\r\n        if (!keys.includes(key)) {\r\n            // @ts-ignore\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    let parseQuery$1 = options.parseQuery || parseQuery;\r\n    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    let routerHistory = options.history;\r\n    if ((process.env.NODE_ENV !== 'production') && !routerHistory)\r\n        throw new Error('Provide the \"history\" option when calling \"createRouter()\":' +\r\n            ' https://next.router.vuejs.org/api/#history.');\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        let recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            let href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        let href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : rawLocation.query,\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string'\r\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\r\n            : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function handleRedirectRecord(to) {\r\n        const lastMatched = to.matched[to.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\r\n            if (typeof newTargetLocation === 'string') {\r\n                newTargetLocation =\r\n                    newTargetLocation.indexOf('?') > -1 ||\r\n                        newTargetLocation.indexOf('#') > -1\r\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\r\n                        : { path: newTargetLocation };\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                throw new Error('Invalid redirect');\r\n            }\r\n            return assign({\r\n                query: to.query,\r\n                hash: to.hash,\r\n                params: to.params,\r\n            }, newTargetLocation);\r\n        }\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const shouldRedirect = handleRedirectRecord(targetLocation);\r\n        if (shouldRedirect)\r\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a push\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => isNavigationFailure(error)\r\n            ? error\r\n            : // reject any unknown error\r\n                triggerError(error))\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-ignore\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-ignore\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords,] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            record.leaveGuards.forEach(guard => {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            });\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                record.updateGuards.forEach(guard => {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                });\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && from.matched.indexOf(record) < 0) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            let toLocation = resolve(to);\r\n            // due to dynamic routing, and to hash history with manual navigation\r\n            // (manually changing the url or calling history.hash = '#/somewhere'),\r\n            // there could be a redirect record in history\r\n            const shouldRedirect = handleRedirectRecord(toLocation);\r\n            if (shouldRedirect) {\r\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\r\n                return;\r\n            }\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\r\n                    // false) but this is bug prone as we have no way to wait the\r\n                    // navigation to be finished before calling pushWithRedirect. Using\r\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\r\n                    // it to work on every browser. So Instead we do not restore the\r\n                    // history entry and trigger a new navigation as requested by the\r\n                    // navigation guard.\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection, let push call triggerError\r\n                    ).catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure && info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     * @param error - error to throw\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error) {\r\n        markAsReady(error);\r\n        errorHandlers.list().forEach(handler => handler(error));\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    /**\r\n     * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n     * only be called once, otherwise does nothing.\r\n     * @param err - optional error\r\n     */\r\n    function markAsReady(err) {\r\n        if (ready)\r\n            return;\r\n        ready = true;\r\n        setupListeners();\r\n        readyHandlers\r\n            .list()\r\n            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n        readyHandlers.reset();\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        const { scrollBehavior } = options;\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(triggerError);\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (let key in START_LOCATION_NORMALIZED) {\r\n                // @ts-ignore: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            app.provide(routerViewLocationKey, currentRoute);\r\n            let unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                if (installedApps.size < 1) {\r\n                    removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp();\r\n            };\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && true) {\r\n                addDevtools(app, router, matcher);\r\n            }\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\r\n                updatingRecords.push(recordFrom);\r\n            else\r\n                leavingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\r\n                enteringRecords.push(recordTo);\r\n            }\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n","import { initCustomFormatter, warn } from '@vue/runtime-dom';\nexport * from '@vue/runtime-dom';\n\nfunction initDev() {\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    initDev();\r\n}\r\nconst compile = () => {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`Runtime compilation is not supported in this build of Vue.` +\r\n            (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n                ) /* should not happen */);\r\n    }\r\n};\n\nexport { compile };\n","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM ||\n      capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n","/**\n * Copyright 2004-present Facebook. All Rights Reserved.\n *\n * @providesModule UserAgent_DEPRECATED\n */\n\n/**\n *  Provides entirely client-side User Agent and OS detection. You should prefer\n *  the non-deprecated UserAgent module when possible, which exposes our\n *  authoritative server-side PHP-based detection to the client.\n *\n *  Usage is straightforward:\n *\n *    if (UserAgent_DEPRECATED.ie()) {\n *      //  IE\n *    }\n *\n *  You can also do version checks:\n *\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\n *      //  IE7 or better\n *    }\n *\n *  The browser functions will return NaN if the browser does not match, so\n *  you can also do version compares the other way:\n *\n *    if (UserAgent_DEPRECATED.ie() < 7) {\n *      //  IE6 or worse\n *    }\n *\n *  Note that the version is a float and may include a minor version number,\n *  so you should always use range operators to perform comparisons, not\n *  strict equality.\n *\n *  **Note:** You should **strongly** prefer capability detection to browser\n *  version detection where it's reasonable:\n *\n *    http://www.quirksmode.org/js/support.html\n *\n *  Further, we have a large number of mature wrapper functions and classes\n *  which abstract away many browser irregularities. Check the documentation,\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\n *  another copy of \"event || window.event\".\n *\n */\n\nvar _populated = false;\n\n// Browsers\nvar _ie, _firefox, _opera, _webkit, _chrome;\n\n// Actual IE browser for compatibility mode\nvar _ie_real_version;\n\n// Platforms\nvar _osx, _windows, _linux, _android;\n\n// Architectures\nvar _win64;\n\n// Devices\nvar _iphone, _ipad, _native;\n\nvar _mobile;\n\nfunction _populate() {\n  if (_populated) {\n    return;\n  }\n\n  _populated = true;\n\n  // To work around buggy JS libraries that can't handle multi-digit\n  // version numbers, Opera 10's user agent string claims it's Opera\n  // 9, then later includes a Version/X.Y field:\n  //\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\n  var uas = navigator.userAgent;\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(uas);\n  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\n\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\n  _android = /Android/i.exec(uas);\n  _native = /FBAN\\/\\w+;/i.exec(uas);\n  _mobile = /Mobile/i.exec(uas);\n\n  // Note that the IE team blog would have you believe you should be checking\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\n  // Windows will send 'WOW64' instead.\n  _win64 = !!(/Win64/.exec(uas));\n\n  if (agent) {\n    _ie = agent[1] ? parseFloat(agent[1]) : (\n          agent[5] ? parseFloat(agent[5]) : NaN);\n    // IE compatibility mode\n    if (_ie && document && document.documentMode) {\n      _ie = document.documentMode;\n    }\n    // grab the \"true\" ie version from the trident token if available\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\n\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\n    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;\n    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;\n    if (_webkit) {\n      // We do not add the regexp to the above test, because it will always\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\n      // the userAgent string.\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\n    } else {\n      _chrome = NaN;\n    }\n  } else {\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\n  }\n\n  if (os) {\n    if (os[1]) {\n      // Detect OS X version.  If no version number matches, set _osx to true.\n      // Version examples:  10, 10_6_1, 10.7\n      // Parses version number as a float, taking only first two sets of\n      // digits.  If only one set of digits is found, returns just the major\n      // version number.\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\n\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\n    } else {\n      _osx = false;\n    }\n    _windows = !!os[2];\n    _linux   = !!os[3];\n  } else {\n    _osx = _windows = _linux = false;\n  }\n}\n\nvar UserAgent_DEPRECATED = {\n\n  /**\n   *  Check if the UA is Internet Explorer.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  ie: function() {\n    return _populate() || _ie;\n  },\n\n  /**\n   * Check if we're in Internet Explorer compatibility mode.\n   *\n   * @return bool true if in compatibility mode, false if\n   * not compatibility mode or not ie\n   */\n  ieCompatibilityMode: function() {\n    return _populate() || (_ie_real_version > _ie);\n  },\n\n\n  /**\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\n   * this when we don't need it -- tracked by #601957.\n   */\n  ie64: function() {\n    return UserAgent_DEPRECATED.ie() && _win64;\n  },\n\n  /**\n   *  Check if the UA is Firefox.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  firefox: function() {\n    return _populate() || _firefox;\n  },\n\n\n  /**\n   *  Check if the UA is Opera.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  opera: function() {\n    return _populate() || _opera;\n  },\n\n\n  /**\n   *  Check if the UA is WebKit.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  webkit: function() {\n    return _populate() || _webkit;\n  },\n\n  /**\n   *  For Push\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\n   */\n  safari: function() {\n    return UserAgent_DEPRECATED.webkit();\n  },\n\n  /**\n   *  Check if the UA is a Chrome browser.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  chrome : function() {\n    return _populate() || _chrome;\n  },\n\n\n  /**\n   *  Check if the user is running Windows.\n   *\n   *  @return bool `true' if the user's OS is Windows.\n   */\n  windows: function() {\n    return _populate() || _windows;\n  },\n\n\n  /**\n   *  Check if the user is running Mac OS X.\n   *\n   *  @return float|bool   Returns a float if a version number is detected,\n   *                       otherwise true/false.\n   */\n  osx: function() {\n    return _populate() || _osx;\n  },\n\n  /**\n   * Check if the user is running Linux.\n   *\n   * @return bool `true' if the user's OS is some flavor of Linux.\n   */\n  linux: function() {\n    return _populate() || _linux;\n  },\n\n  /**\n   * Check if the user is running on an iPhone or iPod platform.\n   *\n   * @return bool `true' if the user is running some flavor of the\n   *    iPhone OS.\n   */\n  iphone: function() {\n    return _populate() || _iphone;\n  },\n\n  mobile: function() {\n    return _populate() || (_iphone || _ipad || _android || _mobile);\n  },\n\n  nativeApp: function() {\n    // webviews inside of the native apps\n    return _populate() || _native;\n  },\n\n  android: function() {\n    return _populate() || _android;\n  },\n\n  ipad: function() {\n    return _populate() || _ipad;\n  }\n};\n\nmodule.exports = UserAgent_DEPRECATED;\n","/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n'use strict';\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n","module.exports = require('./src/normalizeWheel.js');\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule normalizeWheel\n * @typechecks\n */\n\n'use strict';\n\nvar UserAgent_DEPRECATED = require('./UserAgent_DEPRECATED');\n\nvar isEventSupported = require('./isEventSupported');\n\n\n// Reasonable defaults\nvar PIXEL_STEP  = 10;\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n\n/**\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n *\n */\nfunction normalizeWheel(/*object*/ event) /*object*/ {\n  var sX = 0, sY = 0,       // spinX, spinY\n      pX = 0, pY = 0;       // pixelX, pixelY\n\n  // Legacy\n  if ('detail'      in event) { sY = event.detail; }\n  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }\n  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }\n  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }\n\n  // side scrolling on FF with DOMMouseScroll\n  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {\n    sX = sY;\n    sY = 0;\n  }\n\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n\n  if ('deltaY' in event) { pY = event.deltaY; }\n  if ('deltaX' in event) { pX = event.deltaX; }\n\n  if ((pX || pY) && event.deltaMode) {\n    if (event.deltaMode == 1) {          // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {                             // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n  return { spinX  : sX,\n           spinY  : sY,\n           pixelX : pX,\n           pixelY : pY };\n}\n\n\n/**\n * The best combination if you prefer spinX + spinY normalization.  It favors\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\n * 'wheel' event, making spin speed determination impossible.\n */\nnormalizeWheel.getEventType = function() /*string*/ {\n  return (UserAgent_DEPRECATED.firefox())\n           ? 'DOMMouseScroll'\n           : (isEventSupported('wheel'))\n               ? 'wheel'\n               : 'mousewheel';\n};\n\nmodule.exports = normalizeWheel;\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n"],"sourceRoot":""}